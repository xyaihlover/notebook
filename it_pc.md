#关于PC#
***

##计算机小端大端模式##

我们都知道，内存中存储的是各种变量，各种奇葩东西，不用的变量占用不用的字长，例如在intel X86环境下，一个int占用两个字

        0    1    2    3    4    5    6    7    8    9
        30   31   32   33   34   35   36   37   38   39(0x)

节，即16位。然后在这16位上用0或1来表示这个int类型的变量到底是什么数值。那么这样就有两种写法了，在这16位上是从左往右写呢，还是从右往左写呢。这就好比现代人写字从左往右，古人写字从右往左。根据这样两种不同的写法，计算机中就产生了两种模式：小端模式和大端模式。具体来看一个例子：
假设在intel X86环境下，有一个数字，是1539，用二进制就表示为：0000 0110 0000 0011（两个字节）
高八位                低八位
0000 0110         0000 0011
   既然计算机以字节为单位，如果这里的一个字节相当于写一个汉字的话，那这个1539在计算机内部就相当于要写两个汉字。怎么写呢，不着急，先介绍小端模式：按照从低地址到高地址的顺序，依次存放数据的低字节到高字节。
 	                  高八位	         低八位
 小端模式：	 0000 0110       0000 0011

插入一句：一个数的原数，是高字节在左，低字节在右，当然是这样，因为左边的权值高，2的次方高。学习本篇的时候，要始终记住吧一个个字节作为一个个单位，而不要着眼于位。

我这里高八位标在左边，低八位标在右边，很多地方低八位标左，高八位标右，这个其实是完全一样的，怎么看得舒服就怎么写。
按照定义，低地址放低字节，高地址放高字节，所以低八位放1539的低字节，高八位放1539的高字节。
接下来是大端模式：按照从低地址到高地址的顺序，依次存放数据的高字节到低字节。
 	                 高八位	         低八位
 大端模式：	 0000 0011	 0000 0110
现在再回头看看，不过就是正着写反着写而已。╮(╯_╰)╭
一般来说，x86 系列 CPU 都是小端模式的字节序，PowerPC 通常是大端模式字节序，还有的CPU能通过跳线来设置CPU工作于小端模式还是大端模式模式。基本上要考察都是intel x86 x64环境，都是小端模式，不会那么坑考冷门的大端模式。。

练习：
0x1234abcd
                  低地址              高地址
小端模式：0xcd  0xab  0x34  0x12
大端模式：0x12  0x34  0xab  0xcd

写出下列程序的执行结果

>#include<stdio.h>
main()
{
	char *sz = "0123456789";
	int *p = (int*)sz;
	printf("%x\n",*++p);
}

答案是37363534
 '0'	'1'
	'2'
	'3'
	'4'
	'5'
	'6'
	'7'
	'8'
	'9'
0x30
	0x31
	 0x32	 0x33	 0x34	 0x35	 0x36	0x37
	0x38
	0x39
   int *p = (int*)sz; 这句话的意思是说把这块内存当做int来对待。可以这样理解，数据就在内存中摆着，就看你当成什么来用了。
不管32位还是64位，int都占四个字节，printf那边有个++p，这个p是int型的指针，所以按照int的大小走四个字节
即现在p指向的是：
 '0'	'1'
	'2'
	'3'
	'4'
	'5'
	'6'
	'7'
	'8'
	'9'
0x30
	0x31
	 0x32	 0x33	 0x34	 0x35	 0x36	0x37
	0x38
	0x39
这块内存区域。还记得吗，用的是小端模式，那这个int变量该怎么写？
很明显是：0x37363534(低地址存低字节)
所以用%X输出的话就看到了37363534这个结果了。

写出下列程序执行结果

>int a = 0x12345678;
char *p = (char*)(&a);
printf("%x\n",*(p+1));

答案是0x56

判断计算机是大端还是小端：

>int i=1;
char *p=(char *)&i;
if(*p==1)
    printf("小端模式");
else // (*p == 0)
    printf("大端模式");

##网络字节序##

1.网络字节序定义：
收到的第一个字节被当作高位看待，这就要求发送端发送的第一个字节应当是高位。


（2）网络字节序为大端序列：
在发送端发送数据时，发送的第一个字节是该数字在内存中起始地址对应的字节。可见多字节数值在发送前，在内存中数值应该以大端法存放。 


htons():将16位无符号整数从本地字节序转换成网络字节序；
htonl():将32位无符号整数从本地字节序转换成网络字节序；
ntohs():将16位无符号整数从网络字节序转换成本地字节序；
ntohl():将32位无符号整数从网络字节序转换成本地字节序；


（3）举例：
比如我们经过网络发送0x12345678这个整形，在80X86平台中，它是以小端法存放的，在发送前需要使用系统提供的htonl将其转换成大端法存放，如图2所示。

##全双工,半双工##
        准确的说100M的全双工和100M的半双工都是100M的带宽，但是他们的吞吐量是不同的，100M的全双工吞吐量是200M，而100M的半双工吞吐量是100M，带宽≠吞吐量，这是两个概念。
        举个例子吧，同样是100M的链路，一条是全双工，另一条是半双工，如果两条链路上都进行单向通信的话，理论上是都可以达到100M的（注意：这里全双工也只有100M），但是如果两条链路都进行双向通信就不一样了，双向通信时，全双工的链路的吞吐量是200M（两个方向每个方向上都是100M），而半双工最大也只有100M。但是虽然全双工的最大吞吐量能够达到200M，但是他使用的最大带宽永远都是100M，你不可能将双向的200M变成单向的200M。
        因此全双工的带宽＝半双工的带宽，全双工的吞吐量＝2×半双工的吞吐量。

##最小系统法##
* 说法一

        最小系统法是指，从维修判断的角度能使电脑开机或运行的最基本的硬件和软件环境。
        硬件最小系统：由电源,主板和CPU组成，在这个系统中，没有任何信号线的连接，只有电源到主板的电源连接，在判断的过程中通过声音来判断这一核心组成部分是否可正常工作；
        软件最小系统：由电源、主板、CPU、内存、显示卡/显示器、键盘和硬盘组成，这个最小系统主要用来判断系统是否可完成正常的启动与运行。
        
* 说法二

        “最小系统法”是指只保留主板、内存条、CPU、显示卡、显示器和电源等基本设备，先通电检查这些基本设备组成的最小系统，经检查确认保留的最小系统能正常工作以后，再进一步检查其它设备。 
        
* 说法三

        系统最小化，一般是指，只有电源，主板，CPU，内存，显卡来测试问题在那里
        
* 说法四(百度百科)

        最小系统分为3类：
        1. 启动型（电源+主板+CPU）
        2. 点亮型（电源+主板+CPU+内存+显卡+显示器）
        3. 进入系统型（电源+主板+CPU+内存+显卡+显示器+硬盘+键盘），这个时候其实已经是完整的电脑了，不过光驱、软驱、打印机、电视卡、鼠标、摄像头、网卡、手柄之类的还是没有插上。

##BIOS警报声##
* AMI Bios 报警声含义
1短 内存刷新失败 
2短 内存ECC较验错误 
3短 系统基本内存（第一个64KB）检查失败 4短 系统时钟出错 
5短 中央处理器（CPU）错误 6短 键盘控制器错误 
7短 系统实模式错误，不能切换到保护模式 8短 显示内存错误（显示内存可能坏了） 9短 ROM BIOS校验和错误 
1长3短 内存错误（内存损坏，请更换） 
1长8短 显示测试错误（显示器数据线松了或显卡没插稳）
* Award (phoenix) Bios 报警声含义(版本号新旧不一，报警声含义有所差别) 
无报报警声：可能是电源、主板或PC喇叭有问题。检查它们接触是否不良或理换相应部件。 1声短音：正常情况下为此音。 
2声短音：CMOS设置错误引起，重新设置CMOS，一般调用默认设置即可。 1长1短：内存、主板报错，一般是兼容性问题，重新插拔内存。 
1长2短：显示错误，一般是显卡与AGP插槽接触不良，或显示器数据经末接好，也有可能是显卡或显存物理损坏。 
1长3短：键盘控制器报错，首先尝试换键盘。 
1长9短：主板FlashRAM或EPROM错误（BIOS芯片损坏），尝试更换或重新刷新。 长响：内存条末插或接触不良，已损坏，重新插拔或更换内存。 不停地响： 电源，显示器未和显卡连接好。 重复短响： 电源 无声音无显示： 电源 
运行中高频报警：CPU过热，往往由于超频所至，请检查CPU风扇是否运转正常